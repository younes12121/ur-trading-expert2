"""
Signal Performance Tracker
Tracks the outcome of every signal generated by the bot to provide live win rates and social proof.
"""

import json
import os
from datetime import datetime, timedelta

class SignalTracker:
    def __init__(self, data_file="signals_db.json"):
        self.data_file = data_file
        self.signals = []
        self.load_data()

    def load_data(self):
        """Load signal history from file"""
        if os.path.exists(self.data_file):
            try:
                with open(self.data_file, 'r') as f:
                    self.signals = json.load(f)
            except:
                self.signals = []
        else:
            self.signals = []

    def save_data(self):
        """Save signal history to file"""
        with open(self.data_file, 'w') as f:
            json.dump(self.signals, f, indent=2)

    def log_signal(self, pair, direction, entry, tp, sl, timeframe="M15", criteria_passed=None, criteria_total=None, criteria_details=None):
        """Log a new signal
        
        Args:
            pair: Trading pair
            direction: BUY/SELL
            entry: Entry price
            tp: Take profit price
            sl: Stop loss price
            timeframe: Timeframe
            criteria_passed: Number of criteria that passed
            criteria_total: Total number of criteria
            criteria_details: Dict with detailed criteria info (passed/failed)
        """
        signal = {
            'id': len(self.signals) + 1,
            'pair': pair,
            'direction': direction,
            'entry': entry,
            'tp': tp,
            'sl': sl,
            'timeframe': timeframe,
            'status': 'OPEN',  # OPEN, WON, LOST
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'outcome_time': None,
            'pips_gained': 0,
            'criteria_passed': criteria_passed,
            'criteria_total': criteria_total,
            'criteria_details': criteria_details or {}
        }
        self.signals.append(signal)
        self.save_data()
        return signal['id']
    
    def get_signal_by_id(self, signal_id):
        """Get signal by ID"""
        for signal in self.signals:
            if signal['id'] == signal_id:
                return signal
        return None

    def update_outcome(self, signal_id, status, pips=0):
        """Update the outcome of a signal (WON/LOST)"""
        for s in self.signals:
            if s['id'] == signal_id:
                s['status'] = status
                s['pips_gained'] = pips
                s['outcome_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                self.save_data()
                return True
        return False

    def get_live_stats(self):
        """Calculate live statistics for social proof"""
        if not self.signals:
            return {
                'total_signals': 0,
                'win_rate': 0,
                'wins': 0,
                'losses': 0,
                'total_pips': 0
            }

        closed_signals = [s for s in self.signals if s['status'] in ['WON', 'LOST']]
        
        if not closed_signals:
            return {
                'total_signals': len(self.signals),
                'win_rate': 0,
                'wins': 0,
                'losses': 0,
                'total_pips': 0
            }

        wins = [s for s in closed_signals if s['status'] == 'WON']
        losses = [s for s in closed_signals if s['status'] == 'LOST']
        
        win_rate = (len(wins) / len(closed_signals)) * 100
        total_pips = sum(s['pips_gained'] for s in closed_signals)

        return {
            'total_signals': len(self.signals),
            'closed_signals': len(closed_signals),
            'win_rate': round(win_rate, 1),
            'wins': len(wins),
            'losses': len(losses),
            'total_pips': total_pips
        }

    def get_weekly_stats(self):
        """Get stats for the current week"""
        now = datetime.now()
        start_of_week = now - timedelta(days=now.weekday())
        start_of_week = start_of_week.replace(hour=0, minute=0, second=0, microsecond=0)
        
        weekly_signals = []
        for s in self.signals:
            try:
                sig_time = datetime.strptime(s['timestamp'], '%Y-%m-%d %H:%M:%S')
                if sig_time >= start_of_week and s['status'] in ['WON', 'LOST']:
                    weekly_signals.append(s)
            except:
                continue
                
        if not weekly_signals:
            return {'win_rate': 0, 'count': 0, 'pips': 0}
            
        wins = [s for s in weekly_signals if s['status'] == 'WON']
        win_rate = (len(wins) / len(weekly_signals)) * 100
        total_pips = sum(s['pips_gained'] for s in weekly_signals)
        
        return {
            'win_rate': round(win_rate, 1),
            'count': len(weekly_signals),
            'pips': total_pips,
            'wins': len(wins)
        }

    def get_hot_streaks(self):
        """Identify pairs with consecutive wins"""
        streaks = {}
        
        # Group by pair
        pair_signals = {}
        for s in self.signals:
            if s['status'] in ['WON', 'LOST']:
                if s['pair'] not in pair_signals:
                    pair_signals[s['pair']] = []
                pair_signals[s['pair']].append(s)
        
        # Calculate streaks
        for pair, signals in pair_signals.items():
            # Sort by time
            signals.sort(key=lambda x: x['timestamp'], reverse=True)
            
            current_streak = 0
            for s in signals:
                if s['status'] == 'WON':
                    current_streak += 1
                else:
                    break
            
            if current_streak >= 2:
                streaks[pair] = current_streak
                
        return streaks
