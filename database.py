"""
Database Module with SQLAlchemy ORM
Handles PostgreSQL database for user management, signals, trades, subscriptions, and analytics
"""

from sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, DateTime, JSON, ForeignKey, Text, Enum as SQLEnum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from datetime import datetime
import enum
import os

Base = declarative_base()

# ============================================================================
# ENUMS
# ============================================================================

class UserTier(enum.Enum):
    FREE = "free"
    PREMIUM = "premium"
    VIP = "vip"

class SubscriptionStatus(enum.Enum):
    ACTIVE = "active"
    CANCELLED = "cancelled"
    EXPIRED = "expired"
    TRIAL = "trial"

class SignalStatus(enum.Enum):
    OPEN = "open"
    WON = "won"
    LOST = "lost"
    CANCELLED = "cancelled"

class TradeDirection(enum.Enum):
    BUY = "buy"
    SELL = "sell"

# ============================================================================
# MODELS
# ============================================================================

class User(Base):
    """User model with tier and subscription info"""
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    telegram_id = Column(Integer, unique=True, nullable=False, index=True)
    username = Column(String(255))
    first_name = Column(String(255))
    last_name = Column(String(255))
    
    # Tier and subscription
    tier = Column(SQLEnum(UserTier), default=UserTier.FREE, nullable=False)
    subscription_date = Column(DateTime)
    subscription_expiry = Column(DateTime)
    trial_used = Column(Boolean, default=False)
    
    # Trading settings
    capital = Column(Float, default=500.0)
    risk_per_trade = Column(Float, default=1.0)  # Percentage
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    last_active = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    subscriptions = relationship("Subscription", back_populates="user")
    trades = relationship("Trade", back_populates="user")
    notifications = relationship("UserNotification", back_populates="user")
    price_alerts = relationship("PriceAlert", back_populates="user")
    
    def __repr__(self):
        return f"<User(telegram_id={self.telegram_id}, tier={self.tier.value})>"
    
    def is_premium(self):
        return self.tier in [UserTier.PREMIUM, UserTier.VIP]
    
    def is_vip(self):
        return self.tier == UserTier.VIP
    
    def has_feature_access(self, feature):
        """Check if user has access to a specific feature"""
        feature_matrix = {
            'all_assets': [UserTier.PREMIUM, UserTier.VIP],
            'unlimited_alerts': [UserTier.PREMIUM, UserTier.VIP],
            'full_analytics': [UserTier.PREMIUM, UserTier.VIP],
            'mtf_analysis': [UserTier.PREMIUM, UserTier.VIP],
            'risk_calculator': [UserTier.PREMIUM, UserTier.VIP],
            'correlation_check': [UserTier.PREMIUM, UserTier.VIP],
            'csv_export': [UserTier.PREMIUM, UserTier.VIP],
            'education_content': [UserTier.PREMIUM, UserTier.VIP],
            'broker_integration': [UserTier.VIP],
            'private_community': [UserTier.VIP],
            'custom_signals': [UserTier.VIP],
            'live_calls': [UserTier.VIP],
        }
        return self.tier in feature_matrix.get(feature, [])


class Subscription(Base):
    """Subscription history and payments"""
    __tablename__ = 'subscriptions'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    
    tier = Column(SQLEnum(UserTier), nullable=False)
    status = Column(SQLEnum(SubscriptionStatus), default=SubscriptionStatus.ACTIVE)
    
    # Payment info
    stripe_subscription_id = Column(String(255))
    stripe_customer_id = Column(String(255))
    amount = Column(Float)
    currency = Column(String(3), default='USD')
    
    # Dates
    start_date = Column(DateTime, default=datetime.utcnow)
    end_date = Column(DateTime)
    cancelled_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="subscriptions")
    
    def __repr__(self):
        return f"<Subscription(user_id={self.user_id}, tier={self.tier.value}, status={self.status.value})>"


class Signal(Base):
    """Trading signals generated by the system"""
    __tablename__ = 'signals'
    
    id = Column(Integer, primary_key=True)
    
    # Signal details
    pair = Column(String(20), nullable=False, index=True)
    direction = Column(SQLEnum(TradeDirection), nullable=False)
    timeframe = Column(String(10), default='M15')
    
    # Prices
    price = Column(Float, nullable=False)
    entry = Column(Float, nullable=False)
    stop_loss = Column(Float, nullable=False)
    tp1 = Column(Float)
    tp2 = Column(Float)
    
    # Analysis
    confidence = Column(Integer)  # Percentage
    criteria_passed = Column(Integer)
    criteria_total = Column(Integer)
    
    # Status
    status = Column(SQLEnum(SignalStatus), default=SignalStatus.OPEN)
    pips_gained = Column(Float, default=0.0)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, index=True)
    closed_at = Column(DateTime)
    
    # Analysis details (JSON)
    analysis_details = Column(JSON)
    
    def __repr__(self):
        return f"<Signal(pair={self.pair}, direction={self.direction.value}, status={self.status.value})>"


class Trade(Base):
    """User trades (actual trades taken)"""
    __tablename__ = 'trades'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)
    signal_id = Column(Integer, ForeignKey('signals.id'))
    
    # Trade details
    asset = Column(String(20), nullable=False)
    direction = Column(SQLEnum(TradeDirection), nullable=False)
    
    # Prices
    entry = Column(Float, nullable=False)
    exit_price = Column(Float)
    stop_loss = Column(Float)
    tp1 = Column(Float)
    tp2 = Column(Float)
    
    # Position
    position_size = Column(Float)  # Lot size
    
    # Results
    pnl = Column(Float, default=0.0)
    pnl_pct = Column(Float, default=0.0)
    pips = Column(Float, default=0.0)
    
    # Status
    is_open = Column(Boolean, default=True)
    exit_type = Column(String(20))  # TP1, TP2, SL, MANUAL
    
    # Timestamps
    opened_at = Column(DateTime, default=datetime.utcnow)
    closed_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="trades")
    
    def __repr__(self):
        return f"<Trade(user_id={self.user_id}, asset={self.asset}, is_open={self.is_open})>"


class UserNotification(Base):
    """User notification preferences"""
    __tablename__ = 'user_notifications'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, unique=True)
    
    # Notification types
    threshold_alerts = Column(Boolean, default=True)
    price_alerts = Column(Boolean, default=True)
    session_notifications = Column(Boolean, default=True)
    performance_summaries = Column(Boolean, default=True)
    trade_reminders = Column(Boolean, default=True)
    
    # Quiet hours
    quiet_hours_enabled = Column(Boolean, default=False)
    quiet_hours_start = Column(String(5), default='22:00')
    quiet_hours_end = Column(String(5), default='07:00')
    
    # Tracking
    last_weekly_summary = Column(DateTime)
    last_session_notification = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="notifications")
    
    def __repr__(self):
        return f"<UserNotification(user_id={self.user_id})>"


class PriceAlert(Base):
    """Custom price alerts"""
    __tablename__ = 'price_alerts'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False, index=True)
    
    # Alert details
    pair = Column(String(20), nullable=False)
    price = Column(Float, nullable=False)
    direction = Column(String(10))  # 'above' or 'below'
    
    # Status
    triggered = Column(Boolean, default=False)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    triggered_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="price_alerts")
    
    def __repr__(self):
        return f"<PriceAlert(user_id={self.user_id}, pair={self.pair}, price={self.price})>"


class Analytics(Base):
    """System-wide analytics and performance metrics"""
    __tablename__ = 'analytics'
    
    id = Column(Integer, primary_key=True)
    
    # Period
    date = Column(DateTime, nullable=False, index=True)
    period_type = Column(String(20))  # 'daily', 'weekly', 'monthly'
    
    # Signal stats
    total_signals = Column(Integer, default=0)
    signals_won = Column(Integer, default=0)
    signals_lost = Column(Integer, default=0)
    win_rate = Column(Float, default=0.0)
    
    # Performance by asset
    asset_stats = Column(JSON)  # {asset: {signals, win_rate, pips}}
    
    # User stats
    total_users = Column(Integer, default=0)
    free_users = Column(Integer, default=0)
    premium_users = Column(Integer, default=0)
    vip_users = Column(Integer, default=0)
    active_users = Column(Integer, default=0)  # Active in period
    
    # Revenue
    revenue = Column(Float, default=0.0)
    
    def __repr__(self):
        return f"<Analytics(date={self.date}, period_type={self.period_type})>"


# ============================================================================
# DATABASE MANAGER
# ============================================================================

class DatabaseManager:
    """Manages database connections and operations with connection pooling"""
    
    def __init__(self, database_url=None):
        if database_url is None:
            # Default to SQLite for development, PostgreSQL for production
            database_url = os.getenv('DATABASE_URL', 'sqlite:///trading_expert.db')
        
        # Connection pooling configuration for PostgreSQL
        pool_config = {
            'pool_size': int(os.getenv('DB_POOL_SIZE', '10')),
            'max_overflow': int(os.getenv('DB_MAX_OVERFLOW', '20')),
            'pool_timeout': int(os.getenv('DB_POOL_TIMEOUT', '30')),
            'pool_recycle': int(os.getenv('DB_POOL_RECYCLE', '3600')),  # 1 hour
            'pool_pre_ping': True,  # Verify connections before using
            'echo': os.getenv('DB_ECHO', 'false').lower() == 'true'
        }
        
        # Only apply pooling for PostgreSQL
        if database_url.startswith('postgresql://') or database_url.startswith('postgres://'):
            self.engine = create_engine(
                database_url,
                **pool_config,
                connect_args={
                    'connect_timeout': 10,
                    'application_name': 'trading_bot'
                }
            )
        else:
            self.engine = create_engine(database_url, echo=pool_config['echo'])
        
        # Use expire_on_commit=False so returned objects keep their loaded attributes
        self.SessionLocal = sessionmaker(bind=self.engine, expire_on_commit=False)
    
    def create_tables(self):
        """Create all tables"""
        Base.metadata.create_all(self.engine)
        print("Database tables created")
    
    def drop_tables(self):
        """Drop all tables (use with caution!)"""
        Base.metadata.drop_all(self.engine)
        print("WARNING: All tables dropped")
    
    def get_session(self):
        """Get a new database session"""
        return self.SessionLocal()
    
    def migrate_from_json(self, json_files):
        """Migrate data from JSON files to database
        
        Args:
            json_files: dict with keys like 'users', 'trades', 'signals'
        """
        session = self.get_session()
        
        try:
            # Migrate users
            if 'users' in json_files:
                import json
                with open(json_files['users'], 'r') as f:
                    users_data = json.load(f)
                    for user_data in users_data:
                        user = User(
                            telegram_id=user_data['telegram_id'],
                            username=user_data.get('username'),
                            tier=UserTier[user_data.get('tier', 'FREE').upper()],
                            capital=user_data.get('capital', 500.0)
                        )
                        session.add(user)
            
            # Migrate trades
            if 'trades' in json_files:
                import json
                with open(json_files['trades'], 'r') as f:
                    trades_data = json.load(f)
                    for trade_data in trades_data:
                        # Find user by telegram_id
                        user = session.query(User).filter_by(
                            telegram_id=trade_data['telegram_id']
                        ).first()
                        
                        if user:
                            trade = Trade(
                                user_id=user.id,
                                asset=trade_data['asset'],
                                direction=TradeDirection[trade_data['direction'].upper()],
                                entry=trade_data['entry'],
                                stop_loss=trade_data['stop_loss'],
                                tp1=trade_data.get('tp1'),
                                tp2=trade_data.get('tp2'),
                                position_size=trade_data.get('size'),
                                is_open=trade_data.get('is_open', False),
                                pnl=trade_data.get('pnl', 0.0)
                            )
                            session.add(trade)
            
            session.commit()
            print("Data migrated successfully")
            
        except Exception as e:
            session.rollback()
            print(f"ERROR: Migration error: {e}")
            raise
        finally:
            session.close()
    
    def get_user_by_telegram_id(self, telegram_id):
        """Get or create user by Telegram ID"""
        session = self.get_session()
        user = session.query(User).filter_by(telegram_id=telegram_id).first()
        
        if not user:
            user = User(telegram_id=telegram_id, tier=UserTier.FREE)
            session.add(user)
            session.commit()
            session.refresh(user)
        
        session.close()
        return user
    
    def update_user_tier(self, telegram_id, tier, subscription_expiry=None):
        """Update user tier"""
        session = self.get_session()
        user = session.query(User).filter_by(telegram_id=telegram_id).first()
        
        if user:
            user.tier = UserTier[tier.upper()]
            if subscription_expiry:
                user.subscription_expiry = subscription_expiry
            session.commit()
        
        session.close()


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def init_database(database_url=None):
    """Initialize database and create tables"""
    db = DatabaseManager(database_url)
    db.create_tables()
    return db


if __name__ == "__main__":
    # Initialize database
    print("Initializing database...")
    db = init_database()
    print("Database initialized successfully!")

